-----

## 1. üêç Module 1: Fundamentals of Programming

This module established the foundational knowledge for writing correct, readable, and functional Python code.

### 1.1 Python Structure & Syntax

- **Keywords and Identifiers**: Rules for reserved words (`if`, `def`, `while`) vs. user-defined names.
- **Comments**: Using `#` for single-line documentation.
- **Indentation and Statements**: Understanding Python's syntax reliance on 4-space indentation to define code blocks (suites).
- **Expressions vs. Statements**: Distinguishing between code that evaluates to a value (expression: `5 + 2`) and code that performs an action (statement: `print(...)`).

### 1.2 Variables and Data Types

- **Variables**: The role of identifiers in naming memory locations for reusability.
- **Data Types**: Core types including Integers (`int`), Floats (`float`), Strings (`str`), and Booleans (`True`/`False`).
- **Standard Input and Output**: Using `input()` (for Standard Input) and `print()` (for Standard Output).

### 1.3 Operators and Control Flow

**Arithmetic Operators**: 
- Addition (`+`)
- Subtraction (`-`)
- Multiplication (`*`)
- Exponentiation (`**`)
- True Division (`/`)
- Floor Division (`//`)
- Modulo (`%`) operator

**Comparison Operators**: Using operators like `==`, `!=`, `>`, and `<` to form conditions.

**Logical Operators**: Combining conditions using `AND`, `OR`, and `NOT` for complex logic.

**Control Flow**:
- **`if/else/elif`**: Implementing decision-making logic based on Boolean conditions.
- **`while` loop**: Implementing repetition and understanding the necessity of an increment/decrement step to prevent infinite loops.

### 1.4 Summary Table: Python Fundamentals

| Topic | Description |
| :--- | :--- |
| **Syntax & Structure** | Keywords, Identifiers, Comments, and the critical role of **Indentation** and **Statements**. |
| **Data Types & Variables** | Defining and utilizing basic data types (`int`, `float`, `str`, `bool`) and the rules for naming **Variables**. |
| **I/O & Operators** | Handling **Standard Input** (`input()`) and **Output** (`print()`), and using arithmetic and logical **Operators** (`+`, `//`, `%`, `and`, `or`). |
| **Control Flow** | Implementing decision-making logic with **`if/else/elif`** structures and repetition with **`while` loops**. |

-----

## 2. ‚è±Ô∏è Module 2: Python for DataScience: Computational Complexity

This module covered the theory behind algorithm performance and efficiency, essential for scalable data solutions.

- **Why Complexity?** Focus on scalability and improving program efficiency independent of hardware improvements.
- **Big O Notation**: Standardized measurement of an algorithm's worst-case runtime relative to input size ($\mathbf{N}$).

### 2.1 Key Complexities Examined

- **$O(1)$ (Constant Time)**: E.g., accessing a list element by index (`list[0]`).
- **$O(\log N)$ (Logarithmic Time)**: E.g., Binary Search.
- **$O(N)$ (Linear Time)**: E.g., a single loop (like a `while` loop) processing every item once.
- **$O(N^2)$ (Quadratic Time)**: E.g., Nested Loops (the structure to avoid for large $\mathbf{N}$).

### 2.2 Summary Table: Computational Complexity

| Concept | Description |
| :--- | :--- |
| **Complexity Analysis** | Understanding **scalability** and why runtime matters for large datasets ($\mathbf{N}$). |
| **Big O Notation** | Measuring the **worst-case** efficiency using standardized notations. |
| **Key Complexities** | **$O(1)$** (Constant), **$O(\log N)$** (Logarithmic, e.g., Binary Search), **$O(N)$** (Linear), and **$O(N^2)$** (Quadratic, e.g., Nested Loops). |

-----

## 3. üóÑÔ∏è Module 3: SQL and Databases

This extensive module covered database theory, the core querying language, and advanced data manipulation techniques.

### 3.1 Introduction to Databases & Theory

- **Why SQL?** Understanding the need for an RDBMS (Relational Database Management System).
- **Execution of an SQL statement**: The process the database uses to fulfill a query.
- **ACID Properties**: The four core guarantees of reliable transactions: **Atomicity**, **Consistency**, **Isolation**, and **Durability**.
- **Database Inspection**: Commands like `USE`, `DESCRIBE`, and `SHOW TABLES`.

### 3.2 Basic Querying & Filtering

- **`SELECT` and `FROM`**: The mandatory clauses for specifying columns (`*`) and tables.
- **`WHERE`**: Filtering rows based on specific conditions.
- **Comparison Operators**: Filtering with `=`, `<`, `>`, and the Not Equal operator (`<>`).
- **Handling `NULL`**: The special state of "unknown data" and the mandatory use of `IS NULL` and `IS NOT NULL`.
- **`LIMIT` and `OFFSET`**: Controlling the number of returned rows for viewing and pagination.
- **`ORDER BY`**: Sorting the results (ascending `ASC` or descending `DESC`).
- **`DISTINCT`**: Removing duplicate values from the result set.

### 3.3 Aggregation and Grouping

**Aggregate Functions**: Functions that return a single summary value from a set of rows:
- **`COUNT`** ($\mathbf{COUNT(*)}$ vs. $\mathbf{COUNT(column)}$)
- **`MIN`**
- **`MAX`**
- **`AVG`**
- **`SUM`**

**Grouping Data**:
- **`GROUP BY`**: Grouping rows for aggregation.
- **`HAVING`**: Filtering the groups (unlike `WHERE`, which filters rows).
- **Order of keywords**: Understanding the logical execution order of clauses (F-W-G-H-S-O-L).

### 3.4 Joins (Connecting Data)

- **Join and Natural Join**: Understanding how to combine data from two or more tables.
- **Inner Join (`JOIN`)**: Returns only the intersection (matching records) of both tables.
- **Left Join**: Returns all records from the left table, and the matched records from the right.
- **Right Join**: Returns all records from the right table, and the matched records from the left.
- **Outer Join (`FULL JOIN`)**: Returns all records from both tables (where supported).

### 3.5 Summary Table: SQL and Databases

| Topic | Description |
| :--- | :--- |
| **Database Basics** | Introduction to Databases, why use **SQL**, and the four crucial **ACID** properties (Atomicity, Consistency, Isolation, Durability). |
| **Basic Querying** | Core statements: **`SELECT`**, **`FROM`**, **`WHERE`**. Using comparison operators (`=`, `<>`) and handling **`NULL`** values (`IS NULL`). |
| **Aggregation & Grouping** | Summarizing data using **Aggregate Functions** (`COUNT`, `MIN`, `MAX`, `AVG`, `SUM`) and organizing results with **`GROUP BY`** and **`HAVING`**. |
| **Advanced Filtering & Joins**| Using **Logical Operators** (`AND`, `OR`, `NOT`), **`ORDER BY`**, **`LIMIT`**, and connecting related tables with various **JOIN** types (Inner, Left, Right, Outer). |

-----

## ‚öôÔ∏è Project Setup and Dataset

This section guides on setting up the environment, including the necessary database and loading the working dataset.

### Prerequisites

1. **Python:** Ensure you have **Python 3.x** installed.
2. **MySQL:** (For SQL modules) Install a MySQL server or a similar RDBMS (e.g., PostgreSQL, SQLite).
3. **IMDB Dataset:** If studying the data loading section, ensure you have the necessary IMDB dataset files (often provided as part of specific courses or downloaded publicly).

### Installation (Python)

No specific libraries are required for the Python fundamentals, but for data science exercises, you may need:

```bash
pip install numpy pandas # If included in your DataScience section
```

### Data Preparation

The SQL exercises rely on a publicly available dataset:

- **IMDB dataset**: Used for practical querying examples.
- **Load IMDB data**: Instructions for importing the raw data into the MySQL environment.

### Database Setup (SQL)

The SQL module requires a running database instance:

1. Install **MySQL** (or preferred RDBMS).
2. Log into your server:
    ```bash
    mysql -u [your_user] -p
    ```
3. Execute the necessary scripts to **Load IMDB data** and set up the database structure as outlined in the module.

-----


-----

## ü§ù Contributing

This is a personal study repository, but suggestions for better structure, clarity, or efficiency improvements on the code examples are always welcome!

-----

## üìÑ License

This project is for educational and personal use.

-----

**Happy Learning!**

-----
